<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_pigeon</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
Create = on initiale les variabes qui seront utilisées dans les différents événements
on execute du code qui ne doit s'éxécuter qu'à la création de l'objet. Tout le code que vous 
mettez dans le Create n'est éxecutez qu'à la création de l'objet. Pour une execution en continu
voir le Step
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
Execute tous le code contenu, et repart au départ à chaque step, le Step c'est le principal 
on peut tout faire dedans sans avoir besoin des autres événements (sauf le draw). Le step
peut se décomposer en 2 autres étapes, Le begin Step qui s'execute avant le Step et le End Step
qui s'execute aprés

fonction utile
place_meeting(..), place_free(..),... des fonctions testant une collision ou non, execute le code
tant que que la collision est true
ex:
if place_meeting(x+20,y,obj_agent)
    {
    image_blend = c_blue
    }
    
les collision_line(...), collision_rectangle(...) renvoient l'id d'une instance qui se trouve
dans la zone de collision définie.

Des variables utiles
speed et direction = valeur de la vitesse selon direction
hspeed = vitesse horizontale
vspeed = vitesse verticale
sprite_index = sr_pigeon affiche le sprite pigeon
image_speed = 0.3 vitesse d'animation du sprite

*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_agent">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
Evenement de collision. Le code se trouvant à l'intérieur ne s'applique qu'une fois 
jusqu'à ce qu'une nouvelle collision ait lieu avec l'objet précisé.
Possibilité d'utiliser la variable other (qui contient l'Id de l'objet avec lequel on est
en collision) ce qui permet de modifier ses variables!!!!
ex :
if other.image_alpha = 1
    {
    other.image_alpha = 0.5 //On change la valeur de image_alpha de l'instance avec laquelle
                            //Game Maker considère qu'on est en collision et 
                            //qui est décrite par other
    }
Autre truc utile la fonction with(Id)
permet de "rentrer" dans l'objet adverse afin de lui faire effectuer du code, lui
affecter des variables.

ex:
with(other)
    {
    instance_destroy() // vous faites s'autodétruire l'objet other
    }
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
Si vous n'avez qu'une chose à afficher et pas de transformations particulières à faire 
sur les sprites cet évènement n'est pas utile, un sprite_index dans le step suffit. Dans le
cas contraire, si vous devez afficher plusieurs choses :
draw_self() pour afficher le sprite de sprite_index
draw_sprite(...) pour afficher un sprite simple
draw_sprite_ext(...) pour pouvoir appliquer des transformations
draw_text(...)
....
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
